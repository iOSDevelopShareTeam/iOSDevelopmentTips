# 内存管理

## 内存溢出丶野指针异常
系统在一直分配空间的时候会出现内存溢出。
对象内存空间已经被系统回收，仍然使用指针操作这块内存。野指针异常是程序crash的主要原因。代码量越大的程序，越难找出出现野指针的位置。

内存管理的方式
### 垃圾回收（gc）

* MRC （Manual Reference Count）、
手动引用计数：内存的开辟和释放都由程序代码进行控制。相对垃圾回收来说，对内存的控制更加灵活，可以在自己需要释放的时候及时释放，对程序员的要求较高，程序员要熟悉内存管理的机制。
* ARC(Auto Reference Count) 
ios支持的两种机制： MRC  ARC

MRC的内存管理机制是：引用计数。
OC采用引用计数机制管理内存，当一个新的引用指向对象时，引用计数器就递增，当去掉一个引用时，引用计数就递减。当引用计数到零时，该对象就将释放占有的资源。
影响计数的方法：
+ alloc ：开辟空间，让被开辟的空间的引用计数变为1.这是由0到1的过程。
- retain ：开辟内存空间 如果内存空间之前引用计数为1，retain之后变为2 如果引用计数是5，retain之后变为6
- copy：把某一内存区域的内容拷贝一份，拷贝到新的内存空间里去，被拷贝的区域引用计数不变，新的内存区域的引用计数为1.
- release ：引用计数减一，如果内存空间之前引用计数为4，release 之后变为3，如果之前引用计数为1，release之后变为0，内存被系统回收。
- dealloc
dealloc是继承自父类的方法，当对象引用计数为0的时候由对象自动调用。
- autorelease ：未来的某一时刻引用技术减一，乳沟内存之前引用计数为4，autorelease之后仍然为4，未来某个时刻会变为3.

### 内存管理原则
引用计数的增加和减少相等，当引用计数降为0之后，不应该再使用这块内存空间。
凡事用alloc  retain  或者copy让内存的引用计数增加了。就需要使用release或者autorelease让内存的引
用 计数减少。在一段代码内。增加和减少的次数要相等。

## autoreleasepool的使用
通过autoreleasepool控制autorelease对象的释放
向一个对象发送autorelease消息。这个对象何时释放取决于autoreleasepool
copy方法
跟retain不同，一个对象想要copy，生成自己的副本，需要实现NSCopying协议，定义copy的细节（如何copy）如果类没有接受NSCoping协议而给类发送copy消息，会引起crash
总结：
OC借助引用计数机制去管理内存，凡是使用了alloc copy retain 等 方法，增加了引用计数，就要使用release 和autorelease 减少引用计数，引用计数为0的时候，对象所占的内存，被系统回收。
autorelease是未来某个时间（出autorelease）引用减一，不是即时的。
不是任何对象都可以接受copy消息。只有接受了NSCoping协议的对象才接受copy消息。
# C中的内存管理
1. 函数malloc（）和calloc（）都可以用来动态分配内存空间。 malloc（） 函数有一个参数，即分配的内存空间的大小，malloc在分配内存的时候会保留一定的空间用来记录分配情况，分配的次数越多，这些记录占用的空间就越多。 另外，根据malloc实现策略的不同，malloc每次在分配的时候，可能分配的空间比实际要求的多些，多次分配会导致更多的这种浪费，当然，这些都跟 malloc的实现有关； calloc（）函数有两个参数，分别为元素的个数和每个元素的大小，这两个参数的乘积就是要分配的内存空间的大小。如果调用成功，它们都将返回所分配内存空间的首地址。

2. 函数malloc（）和calloc（）的主要区别是前者不能初始化所分配的内存空间，而后者可以。
3. relloc（）可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或者缩小，原有内存中的内容将保持不变。当然，对于缩小，则被缩小的那一部分的内容会丢失。
4. relloc（）并不保证调整后的内存空间和原来的内存空间保持同一内存地址，相反，relloc返回的指针很可能指向一个新地址。所以在代码 中，我们必须将relloc的返回值，重新赋值给p ： p=(int *) relloc (p,sizeof(int)*15);
