# iOSDevelopmentTips
# 无符号类型
1.无符号整型
整型有无符号（unsigned）和有符号（signed）两种类型，在默认情况下声明的整形变量都是有符号的类型（char有点特别），如果需声明无符号类型的话就需要在类型前加上unsigned。无符号整型和有符号整型的区别就是无符号类型可以存放的正数范围比有符号整型中的范围大一倍，比如16位系统中一个int能存储的数据的范围为-32768~32767，而unsigned能存储的数据范围则是0~65535。在一些不可能取值为负数的时候，可以定义为unsigned，在一些底层的嵌入式编程的数据一般都是无符号的。
无符号数只表示大小，有符号数最高位(二进制情况下最高位表示符号位)，在同一操作系统下，有符号数和无符号数的最大数值在大小上的关系是2x+1(x表示有符号数的最大值，2x+1表示无符号数最大值)。二者表示的数据范围大小是相同的，但是范围不同。无符号整型和有符号整型运算依据表示数据的最大值来定（也是计算机中混合数据类型运算的特点，两个不同类型数据运算，会取能表示较大数据的类型作为运算类型），二者数据运算先将有符号整型转换成无符号整型再通过无符号数运算规则来计算。数据如果超出了整型数据表示范围，则用比当前数据类型大的最小数据类型来表示。 
2.无符号字符型
unsigned char是无符号字节型，char类型变量的大小通常为1个字节（1字节=8个位），且属于整型。整型的每一种都有无符号（unsigned）和有符号（signed）两种类型（float和double总是带符号的），在默认情况下声明的整型变量都是有符号的类型（char有点特别），如果需声明无符号类型的话就需要在类型前加上unsigned。无符号版本和有符号版本的区别就是无符号类型能保存2倍于有符号类型的数据，比如16位系统中一个int能存储的数据的范围为-32768~32767，而unsigned能存储的数据范围则是0~65535。

# c语言输入输出缓冲区的概念
1.getchar
getchar()是stdio.h中的库函数，它的作用是从stdin流中读入一个字符，也就是说，如果stdin有数据的话不用输入它就可以直接读取了。而getch()和getche()是conio.h中的库函数，它的作用是从键盘接收字符。getchar带有显示。
    与前面两个函数的区别在于： getchar()函数等待输入直到按回车才结束（前提是缓冲区没有数据），回车前的所有输入字符都会逐个显示在屏幕上。但只有第一个字符作为函数的返回值。
    
```
#include<stdio.h>
#include<conio.h>
void main()
{
    char c;
     c=getchar();
           //getchar()在这里它只返回你输入字符串的第一个字符，并把返回值赋值给c
    putchar(c);
    printf("\n\n");
}
```
这个程序你运行一下，相信你又会有疑问了。这个就是从缓冲区中读取了例子。第一次getchar()时，确实需要人工的输入，但是如果你输了多个字符，以后的getchar()再执行时就会直接从缓冲区中读取了。

```
#include<stdio.h>
#include<conio.h>
void main()
{
    char c;
    while ((c=getchar())!='\n')
        printf("%c",c);
    printf("\n\n");
}
```

程序运行时，首先停下来，等你输入一串字符串，输入完毕后，它把你输入的整个字符串都输出来了，咦，你不是说getchar()只返回第一个字符么，这里怎么？

因为我们输入的字符串并不是取了第一个字符就把剩下的字符串丢掉了，它还在我们的内存中，就好比，开闸放水，我们把水放到闸里去以后，开一次闸就放掉一点，开一次就放掉一点，直到放光了为止，这里开闸动作就相当于调用一次getchar()。我们输入的字符串也是这么一回事，首先我们输入的字符串是放在内存的缓冲区中的，我们调用一次getchar()就把缓冲区中里出口最近的一个字符输出，也就是最前面的一个字符输出，输出后，就把它释放掉了，但后面还有字符串，所以我们就用循环把最前面的一个字符一个个的在内存中释放掉，直到不满足循环条件退出为止。
例子中循环条件里的'\n'实际上就是你输入字符串后的回车符，所以意思就是说，直到遇到回车符才结束循环，而getchar()函数就是等待输入（或缓冲区中的数据）直到按回车才结束，所以实现了整个字符串的输出。当然，我们也可以把循环条件改一下，比如while ((c=getchar())!='a')，什么意思呢，意思就是遇到字符'a'就停止循环，当然意思是如果你输入“12345a213123\n”那么只会输出到a，结果是12345a。

再次注意：用getchar()它是从“流”中间去读取，所以第一个getchar()接受的是刚刚中断的流队列中即将出列的第一个字符（不限于回车符，上面举过例子了），如果流队列不为空，执行getchar()就继续放水，直到把回车符也放空为止，空了之后再在执行getchar()就停下等待你的输入了；我们用getch()为什么每次都是等待用户的输入呢？因为getch()是从键盘接收，即时的接收，并不是从stdin流中去读取数据。

补充：按键盘上的回车产生了2个字符:回车符('\r')和换行符('\n')。回车符'\r'(CR:carriage return:倒车）使光标回到这行的首部，换行符('\n')(new line)然后再换行。

所以当输入字符'w',并按下回车键以后。首先得到回车符。那个getchar函数结束了。 但是还存在一个换行符。所以如果用getchar()来做判断的时候。最好再写一次getchar()清除缓冲区的'\n'.

3．如何清空输入缓冲区的内容？

如果我想让getchar()每次都能够等待用户输入的话就要清空缓冲区，下面就介绍方法（不同平台）

C标准规定 fflush()函数是用来刷新输出（stdout）缓存的。对于输入（stdin），它是没有定义的。但是有些编译器也定义了 fflush( stdin )的实现，比如微软的VC。其它编译器是否也定义了 fflush( stdin )的实现应当查找它的手册。GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓存。

对于没有定义 fflush( stdin )的编译器，可以使用 fgets()函数来代替它（比用 getchar()、scanf()等函数通用性好）。可以这样忽略输入流中留下的回车等其它输入，从而使下一次的输入总保持一个“干净”的状态。（这个是任何平台下都可以的）
```
char sbuf[1024];
// ...
fgets( sbuf, 1024, stdin );
// ...
在windows 的vc下面就可以这样了：
for(int i=0;i<10;++i)
{
       char ch=getchar();
       fflush(stdin); //每次都会有等待状态了
}
``` 
这里说到gcc编译器没有定义fflush的实现,我们一般用getchar();来清除缓冲区.
下面是我的讨论:
先来一段code:
```
#include <stdio.h>
main()
{
    char c;
    for(;(c=getchar())!='a';)
    printf("%c",c);
    getchar();
     c=getchar();
    printf("%c",c);
}
``` 
```
输入:
ssss回车
得到:
ssss
```
光标处(等待输入)
说明:此时程序没有结束,进行到for循环,因为并没有字符a出现,所以还没跳出for循环.键入回车后,getchar
依次从缓冲区内取出(for循环):'s''s''s''s''\n'
如果我们输入:
ssssa回车
得到:
ssss光标处(等待输入)
说明:程序已经跳出for循环,但是由于我们用getchar();清除了换行'\n',后面第7句c=getchar();需要你输入一个字符(因为ssssa后面并没有新的字符)，所以程序仍然没有结束.如果我们注释掉getchar();这一句，那么得到：
ssss
光标处(程序结束)
这个输入ssssa是的回车中的换行符'\n'就被c=getchar();这一句读取并输出了。
总结:
键盘输入的字符都存到缓冲区内,一旦键入回车,getchar就进入缓冲区读取字符,一次只返回第一个字符作为getchar函数的值,如果有循环或足够多的getchar语句,就会依次读出缓冲区内的所有字符直到'\n'.要理解这一点,之所以你输入的一系列字符被依次读出来,是因为循环的作用使得反复利用getchar在缓冲区里读取字符,而不是getchar可以读取多个字符,事实上getchar每次只能读取一个字符.如果需要取消'\n'的影响,可以用getchar();来清除,这里getchar();只是取得了'\n'但是并没有赋给任何字符变量,所以不会有影响,相当于清除了这个字符.还要注意的是这里你在键盘上输入ssss看到的回显正是来自于getchar的作用,如果用getch就看不到你输入了什么.

1.机理
你键盘输入了东西,而此时你又没有用程序去getchar她,请问这个时候你按的键的状态保存在何处?为什么你一会儿去getchar的时候能得到呢
(例子好举,你先做一个1分钟延迟,然后再getchar,会发现一分钟前按的东西会显示出来)
实际上是 输入设备->内存缓冲区->程序getchar
你按的键是放进缓冲区了,然后供程序getchar
你有没有试过按住很多键然后等一会儿会滴滴滴滴响,就是缓冲区满了,你后头按的键没有存进缓冲区.

2.getchar()和getch()
然后就可以给你讲了
getchar是回车以后才进缓冲区
getch是每次都进缓冲区
用你的程序来说(我怎么觉得应该是\n不是/n)
其实你输入computer,没按回车之前, 运行都停止在
getchar()里头,根本没有进入循环,自然也没有运行printf
当你一按回车,才从getchar出来,然后以后因为键盘缓冲区里头有东西,就一个一个字符getchar出来了
想立刻回显,用getch就好了

2.scanf
scanf这个库函数比较奇怪,而且存在一定的缺陷,所以很多人都不用了,这里还是要简单介绍一下.
scanf输入字符串,整型,实型等数据判断的方式都一样,回车,空格,tab键都认为是一个数据的结束,当然字符的话,一个字符就是结束了,回车,空格等都有对应的ascii码,所以用scanf输入字符时要小心这些东东被当成字符输进去,而输入字符串和整型,实型等数据时这些都被当成分隔符而不会被输入到字符数组或变量里.当然如果输入格式不是"%s%s"而是"%s,%s"分隔符就是逗号了,这个讲到输入输出函数时再说.
说了这么多举几个例子:
```
#include <stdio.h>
int main()
{
char n1[10];
char n2[10];
scanf("%s",n1);
scanf("%s",n2);
printf("n1=%s,n2=%s",n1,n2);
}
```
输入:
hello回车
world回车
得到:
n1=hello,n2=wolrd光标处(程序结束)
这里hello后面就是输入再多个回车,空格也不会被赋值到n2中的,因为他们只是分隔符.
如果输入:
hello回车
光标处(等待输入)
说明回车被认成分隔符,所以程序还要你输入一个字符串来赋给n2.
其实这时缓冲区里是有一个'\n'被留下来的,程序改成这样:
```
#include <stdio.h>
int main()
{
char n1[10];
char n2[10];
char n3,n4;
scanf("%s",n1);
scanf("%s",n2);
printf("n1=%s,n2=%s",n1,n2);
n3=getchar();
printf("%c",n3);
//n4=getchar();
//printf("%c",n4);
}
```
输入:
hello回车
world回车
得到:
hello
world
n1=hello,n2=wolrd
光标处(程序结束)
如果取消最后两行的注释,同样的输入得到:
hello
world
n1=hello,n2=wolrd
光标处(等待输入)
说明此时缓冲区内只有一个'\n',第二个getchar就需要你再输入一个字符了,缓冲区内已经没有字符了.
scanf不会把回车空格赋给字符串但是会赋给字符,就如同getchar一样,这时就要考虑'\n'的存在了.
比如:
```
#include <stdio.h>
int main()
{
char n1[10];
char n2;
scanf("%s",n1);
scanf("%c",&n2);
printf("n1=%s,n2=%d",n1,n2);
}
``` 
输入:
hello回车
得到:
n1=hello,n2=10光标处(程序结束) //10是'\n'的ascii码.
如果输入:
hello 空格回车(一定要有回车,因为scanf也是要等回车,准确说是'\r'才会去读缓冲区的.)
得到:
n1=hello,n2=32光标处(程序结束) //32是空格的ascii码.
再罗嗦一下,如果最后一句输入n2=%d改成n2=%c,则输入:
hello回车
得到:
n1=hello,n2=
光标处(程序结束)
是不是和getchar一样可以把'\n'读出来呢,呵呵.
总结一下就是:
如果scanf输入的不是字符,那么分隔符为回车,空格,tab键时,两个数据之间的分隔符只是起区别两个数据的作用,把分隔好的两个数据分别赋值到各自定义好的变量或数组中去,两个数据之间的分隔符被从缓冲区读出但是不起任何作用,当然最后一个'\n'会被留在缓冲区内,除非用getchar();或scanf("%c",&c);把它读出来.
回车是一定要有的,不管getchar还是scanf只要是通过缓冲区输入数据的函数都是等待回车键'\r'出现才进入缓冲区的.再来个整型数据,字符串,字符的混合例子:
```
#include <stdio.h>
int main()
{
int a,b,c;
char n1[10];
char n2,n3;
scanf("%d%d",&a,&b);
scanf("%c",&n2);
scanf("%d",&c);
scanf("%s",n1);
scanf("%c",&n3);
printf("a=%d,b=%d,n2=%c,c=%d,n1=%s,n3=%c",a,b,n2,c,n1,n3);
}
``` 
输入:
12(若干空格或回车就不影响结果,这里用了回车)
34(这里还要求输入，因为scanf只得到了一个整型数据，而缓冲区内没有整型数据了。要有回车或空格表示这个数据结束了,留下来的空格或回车被下个%c接受,这里用了回车,可以试一下空格)
45 jfdkjfa(回车)
得到:
a=12,b=34,n2=
,c=45,n1=jfdkjfa,n3=
光标处(程序结束)
这里说明一下过程：在前两个整型数据输入时，两个数据之间无论是回车还是若干空格都被scanf当做分隔符，好了，scanf读到分隔符(回车或空格)时，把第一个整型数据送到变量a中，缓冲区中留下分隔符和下面的整型数据，这时scanf再读当然先读分隔符，但是要求输入的还是整型数据(%d)，所以分隔符被忽略，如果这时要求输入字符%c(不是字符串%s)，那么分隔符将以一个字节的形式送到字符变量里，就如同这里的n2.同理可以知道c和n1的保存过程，最后的n3正是接收了输入时的最后一个回车.
好了如果看到这里你都理解了那么看最后一个例子:
```
#include <stdio.h>
main(){
int a;
char ch;
scanf("%d",&a);
ch=getchar();
printf("%d,%c",a,ch);
}
``` 
输入:
95回车
得到:
95,
光标处(程序结束)
很明显这是由于分隔符(回车)被getchar读取并输出了,如果加入一句:getchar();
```
#include <stdio.h>
main(){
int a;
char ch;
scanf("%d",&a);
getchar();
ch=getchar();
printf("%d,%c",a,ch);
}
``` 
输入:
95回车
c回车
得到:
95,c光标处(程序结束) 

来源：[c语言输入输出缓冲区](https://blog.csdn.net/qiongqiong421122/article/details/16867473)

# strcpy函数
```
 charres[100] = {0};
   chara[] ="12345";
   strcpy( res, a );
   strcpy( res +1, res );
   puts( res );
   return0;
```

结果是112345
The strcpy function copies the string pointed to by s2 (including the terminating null
character) into the array pointed to by s1. If copying takes place between objects thatoverlap, the behavior is undefined
res+1表示的是字符数组res的res[1] 的地址。这道题相当于把res复制到res[1]及之后的空间。

