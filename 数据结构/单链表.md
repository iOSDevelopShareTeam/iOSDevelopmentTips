
## 单链表的插入

单链表在第i个数据插入结点的思路
* 声明一指针p指向链表的头结点，初始化j从1开始。
* 当就j<1时，遍历链表，让p的指针向后移动，不断指向下一结点，j++
* 若链表的末尾p为空，那么说明第i个结点不存在，返回error
* 若查找成功，在系统中生成一个空结点s
* 将数据元素e赋值给s->data
* 单链表的插入标准语句s->next=p->next, p->next=s
* 返回成功

代码如下：
```
// 初始条件：顺序线性表L已存在，1<=i<ListLength(L)。
// 操作结果是：在L中第i个结点的位置之前插入新的数据元素e,L的长度+1
Status ListInset (LinkList *L, int i, ElemType e) {
	int j;
	LinkList p,s;
	p = *L;
	j = 1;
	// 寻找第i-i个节点
	while (p && j < i) {
		p = p->next;
		++j;
	}
	// 如果第i个接点不存在
	if (!p || j > i)
	{
     return ERROR;
	}
	s = (LinkList)malloc(sizeof(Node));// 生成新的结点
	s->data = e;// 新结点的数据赋值
	s->next = p->next;// 将p的后继节点赋值给s的后继结点
	p->next = s;//把s的赋值给p的后继
	return ok;

}
```

## 单链表的删除

单链表第i个数据删除结点的算法思路
1. 声明一指针p指向链表头指针，初始化j从1开始;
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1;
3. 若链表末尾p为空，则说明第i个元素不存在;
4. 否则查找成功，将欲删除的结点p->next 赋值给q;
5. 单链表的删除标准语句p->next=q->next;
6. 将q结点中的数据赋值给e，作为返回;
7. 释放q结点;
8. 返回成功。

实现代码算法如下：
```
/* 初始条件：顺序线性表L已存在，1<=i<=ListLength(L) */
/* 操作结果：删除L的第i个数据元素， */
Status ListDelete(LinkList *L, int i, ElemType *e) 
{
  int j;
  LinkList p,q;
  p = *L;
  j = 1;
  // 寻找遍历第i个元素并将p的next指向p，直到找到i为止
  while (p->next && j < 1) {
   p = p->next;
   ++j;
  }
  // 如果第i个元素不存在，报错
  if (!(p->next) || j > i)
  {
  	return ERROR;
  }

  q = p->next;
  // 将q的后继赋值给p的后继
  p->next = q->next;
  // 因为要获取释放结点的值，所以这里要把释放结点的值赋值给*e
  *e = q->data;
  // 利用c语言的函数free 让系统回收此结点，释放内存
  free(q);
  return OK;
}
```
